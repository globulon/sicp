;;;#lang r5rs

(define (filter p? xs)
  (cond ((null? xs) '())
        ((p? (car xs)) (cons (car xs) (filter p? (cdr xs))))
        (else (filter p? (cdr xs)))))


(define (require p)
  (if (not p) (amb)))

(define (an-element-of items)
  (require (not (null?) item))
  (amb (car items) (an-element-of items)))

(define (an-integer-starting-from n)
  (amb n (an-integer-starting-from (+ n 1))))

(define (square n)
  (* n n))

(define (an-integer-between low high)
  (require (<= low high))
  (amb low (an-integer-between (+ low 1) high)))
 
(define (a-pythagorean-triple-between low high)
  (let ((i (an-integer-between low high)))
    (let ((j (an-integer-between i high)))
      (let ((k (an-integer-between j high)))
        (require (= (square k) (+ (square i) (square j))))
        (list i j k)))))


(define (a-pythagorean-triple-from low)
  (let ((k (an-integer-starting-from low)))
    (let ((i (an-integer-between low k)))
      (let ((j (an-integer-between i k)))
        (require (= (square k) (+ (square i) (square j))))
        (list i j k)))))

(define (multiple-dwelling)
  (let ((baker (amb 1 2 3 4 5))
        (cooper (amb 1 2 3 4 5))
        (fletcher (amb 1 2 3 4 5))
        (miller (amb 1 2 3 4 5))
        (smith (amb 1 2 3 4 5)))
    (require (distinct? (list baker cooper fletcher miller smith)))
    (require (not (= baker 5)))
    (require (not (= cooper 1)))
    (require (not (= fletcher 5)))
    (require (not (= fletcher 1)))
    (require (> miller cooper))
    (require (not (= smith (abs (- fletcher 1)))))
    (require (not (= smith (abs (+ fletcher 1)))))
    (require (not (= fletcher (abs (- cooper 1)))))
    (require (not (= fletcher (abs (+ cooper 1)))))
    (list (list 'baker baker)
          (list 'cooper cooper)
          (list 'fletcher fletcher)
          (list 'miller miller)
          (list 'smith smith))))
 
;;; ex 4.40
(define (multiple-dwelling-floor)
  (let ((cooper (amb 2 3 4 5))
        (miller (amb 1 2 3 4 5)))
    (require (> miller cooper))
    (let ((fletcher (amb 2 3 4)))
      (require (not (= fletcher (abs (- cooper 1)))))
      (require (not (= fletcher (abs (+ cooper 1)))))
      (let ((smith (amb 1 2 3 4 5)))
        (require (not (= smith (abs (- fletcher 1)))))
        (require (not (= smith (abs (+ fletcher 1)))))
        (let ((baker (1 2 3 4)))
          (require (distinct? (list baker cooper fletcher miller smith)))
          (list (list 'baker baker)
                (list 'cooper cooper)
                (list 'fletcher fletcher)
                (list 'miller miller)
                (list 'smith smith)))))))
  
    
;;; in essence ex 4.41
  (define (flatten xss)
    (if (null? xss) 
        '()
        (append (car xss) (flatten (cdr xss)))))

(define (mix xs yss)
  (flatten (map (lambda (x)
               (map (lambda (y) (cons x y)) yss))
             xs)))

(define (combine xss)
  (define (unflatten xs) (map (lambda (x) (list x)) xs))

  (if (null? (cdr xss)) 
      (unflatten (car xss))
      (let ((current (car xss))
            (next (combine (cdr xss))))
        (mix current next))))

(define (has-item? x xs)
  (cond ((null? xs) #f)
        ((= (car xs) x) #t)
        (else (has-item? x (cdr xs)))))

(define (distinct? xs)
  (cond ((null? xs) #t)
        ((null? (cdr xs)) #t)
        (else (and (not (has-item? (car xs) (cdr xs)))
                   (distinct? (cdr xs))))))

;;4.41 classic approach makes thing heavier to read 
(define (multiple-dwelling-floor-classic)
  (define (not-neighbours xs)    
    (not (or (= (car xs) (abs (- (cadr xs) 1)))
             (= (car xs) (+ (cadr xs) 1)))))
  (let ((step-one (combine '((2 3 4 5) (1 2 3 4 5)))))
    (let ((cooper-miller (filter (lambda (comb) (> (cadr comb) (car comb))) step-one)))
      (let ((step-two (mix '(2 3 4) cooper-miller)))
        (let ((fletcher-cooper-miller (filter not-neighbours step-two)))
          (let ((step-three (mix '(1 2 3 4 5) fletcher-cooper-miller)))
            (let ((smith-fletcher-cooper-miller (filter not-neighbours step-three)))
              (let ((step-four (mix '(1 2 3 4) smith-fletcher-cooper-miller)))
                (let ((result (car (filter distinct? step-four))))
                  (list (list 'baker (car result))
                        (list 'cooper (cadddr result))
                        (list 'fletcher (caddr result))
                        (list 'miller (car (cddddr result)))
                        (list 'smith (cadr result))))))))))))

;;4.42
(define (liars)
  (define (xor first-affirmation second-affirmation)
    (or (and first-affirmation (not second-affirmation))
        (and (not first-affirmation) second-affirmation)))
  (let ((betty (amb 1 2 3 4 5))
        (ethel (amb 1 2 3 4 5))
        (joan (amb 1 2 3 4 5))
        (kitty (amb 1 2 3 4 5))
        (mary (amb 1 2 3 4 5)))   
    (require (xor (= 3 betty ) (= kitty 2)))
    (require (xor (= 1 ethel ) (= joan 2)))
    (require (xor (= 3 joan ) (= ethel 5)))
    (require (xor (= 2 kitty ) (= mary 4)))
    (require (xor (= 4 mary ) (= betty 1)))
    (require (distinct? betty ethel joan kitty mary))
    (list (list 'betty betty)
          (list 'ethel ethel)
          (list 'joan joan)
          (list 'kitty kitty)
          (list 'mary mary))))

;;4.43 fathers and daugthers
;; moore 1 - downing 2 - hall 3 - hood 4 - parker 5
;; mary    - lorna     - gabrielle - melissa - rosalind
(define (fathers-and-daugthers)
  (define (father-of daughter)
    (cond ((= daughter 2) 'downing)
          ((= daughter 3) 'hall)
          (else 'parker)))
  (let ((lorna (amb 2 3 5))
        (rosalind (amb 2 5))
        (gabrielle (amb 2 3)))
    (require (or (= 5 rosalind) (= 5 lorna)))
    (require (distinct? lorna rosalind gabrielle))
    (father-of lorna)))

;;4.44 eight queens
(define (eight-queens n)
  (define (generate-position)
    (list (an-integer-between 1 n)
          (an-integer-between 1 n)))
  (define (row queen) (car queen))
  (define (col queen) (cadr queen))
  (define (slope first-queen second-queen)
    (abs (/ (- (col first-queen) (col second-queen)) 
            (- (row first-queen) (row second-queen)))))
  (define (assert-position first-queen second-queen)
    (require (not (= (col first-queen) (col second-queen))))
    (require (not (= (row first-queen) (row second-queen))))
    (require (not (= 1 (slope first-queen second-queen)))))
  (define (assert-positions queen queens)
    (for-each (lambda (other) (assert-position queen other)) 
              queens))
  (define (loop n queens)
    (if (= n 0)
        queens
        (let ((queen (generate-position)))
          (assert-positions queen queens)
          (loop (- n 1) (cons queen queens)))))
  (loop n '()))